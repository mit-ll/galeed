Don't forget to change the args themselves!!
* steps are not directly relevant to get operation

Steps for get-unsafe (may need to repeat once per arg):
- - allocate space for struct pointer, align (need to be able to check alignment?)
* - allocate other variables
- - store arg struct pointer in allocated space
* - lifetime start information of other variables
- - load arg struct pointer from allocated space
- - getelementptr gets the pointer to the right field from the struct
- - load the data from the field
* - store field data in other variable allocation
* - lifetime end information of other variables
* - return void

Steps for get-safe:
- - allocate space for FakePtr (one to copy from arg)
* - allocate other variables
- - allocate space for other FakePtrs (one per get_x_... function call) (is this really necessary?)
- - value is passed in as i32, copy it to field of first allocated FakePtr (getelementptr along the way)
* - lifetime start information of other variables
- - (whole sequence of calls to copy the FakePtr, is this even necessary?)
- - call to get_x_..._ffi with i32 from arg
* - store result in other variable allocation
* - lifetime end information of other variables
* - return void

Stripped steps for get-unsafe:
- - allocate space for struct pointer, align (need to be able to check alignment?)
- - store arg struct pointer in allocated space
- - load arg struct pointer from allocated space
- - getelementptr gets the pointer to the right field from the struct
- - load the data from the field

Stripped steps for get-safe:
- - allocate space for FakePtr (one to copy from arg)
  - - allocate space for other FakePtrs (one per get_x_... function call) (is this even necessary?)
- - getelementptr gets the field pointer from the allocated FakePtr
- - store i32 from arg value in previous pointer
  - - (whole sequence of calls to copy the FakePtr into those other allocations, is this even necessary?)
- - call to get_x_..._ffi with i32 from arg (need to get arg back again using getelemptr/load)

(Stripped) Steps for set-unsafe:
- - allocate space for struct pointer, align (need to be able to check alignment?)
- - store arg struct pointer in allocated space
- - load arg struct pointer from allocated space
- - getelementptr gets the pointer to the right field from the struct
- - store the data into the field

(Stripped) Steps for set-safe:
- - allocate space for FakePtr (one to copy from arg)
  - - allocate space for other FakePtrs (one per get_x_... function call) (is this even necessary?)
- - getelementptr gets the field pointer from the allocated FakePtr
- - store i32 from arg value in previous pointer
  - - (whole sequence of calls to copy the FakePtr into those other allocations, is this even necessary?)
- - call to set_x_..._ffi with i32 from arg (need to get arg back again using getelemptr/load)



Transformation:
ARGUMENTS
  TBD
ALLOCATION
- change allocation of MyStruct* to allocate FakePtr<MyStruct> instead
- change store instruction for argument to match new allocation
  - also requires inserting a getelementptr instruction right before
GET
- change any get getelementptr performed on MyStruct to a call to get_(blank)_..._ffi()
  - Old version should have a load immediately after (this load will be removed)
  - Old version should have a load immediately before (this load will also be removed)
  - Keep arg # from getelementptr instruction, will be used to identify correct ffi function
  - Requires inserting a pair of instructions before new call, getelementptr/load to get the FakePtrId out of where we allocated it
SET
- all same as GET, except old version will have a store immediately after instead of a load

Additional Considerations:
- Different types might be a pain
- From now on, do release builds so that we don't have to propagate debug information (for MVP at least)
- have to use index into struct instead of named fields
- make sure to give names to things, to avoid the %number problem.
  - also see about giving old ones names for ease of transformation
- do I need to care about TBAA? (probably, but not for MVP)
- can noalias attribute help later on?
- Need to determine which structs to replace (default to all of them) what's the rule?


ORIGINAL INSTRUCTIONS: 1 GET X

warning: I saw a function called havefunwith_mystruct_safe!
warning: I saw argument #0 with type IntegerTyID
warning: Block name: %1
warning:   Instr:   %2 = alloca %struct.FakePtr, align 4
warning:   Instr:   %3 = alloca i32, align 4
warning:   Instr:   %4 = alloca %struct.FakePtr, align 4
warning:   Instr:   %5 = getelementptr inbounds %struct.FakePtr, %struct.FakePtr* %2, i32 0, i32 0
warning:   Instr:   store i32 %0, i32* %5, align 4
warning:   Instr:   %6 = bitcast i32* %3 to i8*
warning:   Instr:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %6) #4
warning:   Instr:   %7 = bitcast %struct.FakePtr* %4 to i8*
warning:   Instr:   %8 = bitcast %struct.FakePtr* %2 to i8*
warning:   Instr:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 4, i32 4, i1 false)
warning:   Instr:   %9 = getelementptr inbounds %struct.FakePtr, %struct.FakePtr* %4, i32 0, i32 0
warning:   Instr:   %10 = load i32, i32* %9, align 4
warning:   Instr:   %11 = call i32 @get_x_in_MyStruct_ffi(i32 %10)
warning:   Instr:   store i32 %11, i32* %3, align 4, !tbaa !3
warning:   Instr:   %12 = bitcast i32* %3 to i8*
warning:   Instr:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %12) #4
warning:   Instr:   ret void
warning: I saw a function called havefunwith_mystruct_unsafe!
warning: I saw argument #0 with type PointerTyID (pointing to a StructTyID (with struct name: struct.MyStruct))
warning: Block name: %1
warning:
warning:   %2 = alloca %struct.MyStruct*, align 8
warning:   %3 = alloca i32, align 4
warning:   store %struct.MyStruct* %0, %struct.MyStruct** %2, align 8, !tbaa !3
warning:   %4 = bitcast i32* %3 to i8*
warning:   call void @llvm.lifetime.start.p0i8(i64 4, i8* %4) #4
warning:   %5 = load %struct.MyStruct*, %struct.MyStruct** %2, align 8, !tbaa !3
warning:   %6 = getelementptr inbounds %struct.MyStruct, %struct.MyStruct* %5, i32 0, i32 0
warning:   %7 = load i32, i32* %6, align 4, !tbaa !7
warning:   store i32 %7, i32* %3, align 4, !tbaa !11
warning:   %8 = bitcast i32* %3 to i8*
warning:   call void @llvm.lifetime.end.p0i8(i64 4, i8* %8) #4
warning:   ret void

ORIGINAL INSTRUCTIONS: 1 SET X

warning: I saw a function called havefunwith_mystruct_safe!
warning: I saw argument #0 with type IntegerTyID
warning: Block name: %1
warning:   Instr:   %2 = alloca %struct.FakePtr, align 4
warning:   Instr:   %3 = alloca %struct.FakePtr, align 4
warning:   Instr:   %4 = getelementptr inbounds %struct.FakePtr, %struct.FakePtr* %2, i32 0, i32 0
warning:   Instr:   store i32 %0, i32* %4, align 4
warning:   Instr:   call void @llvm.dbg.declare(metadata %struct.FakePtr* %2, metadata !116, metadata !DIExpression()), !dbg !117
warning:   Instr:   %5 = bitcast %struct.FakePtr* %3 to i8*, !dbg !118
warning:   Instr:   %6 = bitcast %struct.FakePtr* %2 to i8*, !dbg !118
warning:   Instr:   call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 4, i32 4, i1 false), !dbg !118
warning:   Instr:   %7 = getelementptr inbounds %struct.FakePtr, %struct.FakePtr* %3, i32 0, i32 0, !dbg !119
warning:   Instr:   %8 = load i32, i32* %7, align 4, !dbg !119
warning:   Instr:   call void @set_x_in_MyStruct_ffi(i32 %8, i32 5), !dbg !119
warning:   Instr:   ret void, !dbg !120
warning: I saw a function called havefunwith_mystruct_unsafe!
warning: I saw argument #0 with type PointerTyID (pointing to a StructTyID (with struct name: struct.MyStruct))
warning: Block name: %1
warning:
warning:   %2 = alloca %struct.MyStruct*, align 8
warning:   store %struct.MyStruct* %0, %struct.MyStruct** %2, align 8, !tbaa !101
warning:   call void @llvm.dbg.declare(metadata %struct.MyStruct** %2, metadata !100, metadata !DIExpression()), !dbg !105
warning:   %3 = load %struct.MyStruct*, %struct.MyStruct** %2, align 8, !dbg !106, !tbaa !101
warning:   %4 = getelementptr inbounds %struct.MyStruct, %struct.MyStruct* %3, i32 0, i32 0, !dbg !107
warning:   store i32 5, i32* %4, align 4, !dbg !108, !tbaa !109
warning:   ret void, !dbg !113